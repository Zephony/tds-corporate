name: Deploy to DigitalOcean Dev or Demo Server

# This workflow builds Docker images, pushes them to Docker Hub,
# then connects to the production droplet via SSH to pull/run the latest containers with Docker Compose.
# It finishes by running an external health check against the publicly exposed domain.

on:
  push:
    branches: [ demo ]
  workflow_dispatch:

jobs:
  deploy-demo:
    if: github.ref_name == 'demo'
    runs-on: ubuntu-latest
    environment: demo
    
    steps:
    # 1) Check out the repository so subsequent steps can access code and Dockerfiles.
    - name: Checkout code
      uses: actions/checkout@v4

    # 2) Enable Buildx for more reliable Docker builds and cross-platform support.
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # 3) Authenticate to Docker Hub using a Personal Access Token (preferred) or password.
    #    Set secrets DOCKERHUB_USERNAME and DOCKERHUB_TOKEN in the repo settings.
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ vars.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    # 4) Build and push images with Buildx to avoid storing large local layers.
    #    Use registry cache and prune between builds to minimize disk usage.
    - name: Build and push backend image
      uses: docker/build-push-action@v6
      with:
        context: .
        file: docker/backend/Dockerfile
        push: true
        platforms: linux/amd64
        tags: docker.io/${{ vars.DOCKERHUB_USERNAME }}/tds-admin-backend:${{ github.sha }}
        cache-from: type=registry,ref=docker.io/${{ vars.DOCKERHUB_USERNAME }}/tds-admin-backend:buildcache
        cache-to: type=registry,mode=max,ref=docker.io/${{ vars.DOCKERHUB_USERNAME }}/tds-admin-backend:buildcache

    # - name: Build and push celery image
    #   uses: docker/build-push-action@v6
    #   with:
    #     context: .
    #     file: docker/celery/Dockerfile
    #     push: true
    #     platforms: linux/amd64
    #     tags: docker.io/${{ vars.DOCKERHUB_USERNAME }}/tds-admin-celery:${{ github.sha }}
    #     cache-from: type=registry,ref=docker.io/${{ vars.DOCKERHUB_USERNAME }}/tds-admin-celery:buildcache
    #     cache-to: type=registry,mode=max,ref=docker.io/${{ vars.DOCKERHUB_USERNAME }}/tds-admin-celery:buildcache

    - name: Build and push frontend image
      uses: docker/build-push-action@v6
      with:
        context: .
        file: docker/frontend/Dockerfile
        target: runner
        push: true
        platforms: linux/amd64
        tags: docker.io/${{ vars.DOCKERHUB_USERNAME }}/tds-admin-frontend:${{ github.sha }}
        cache-from: type=registry,ref=docker.io/${{ vars.DOCKERHUB_USERNAME }}/tds-admin-frontend:buildcache
        cache-to: type=registry,mode=max,ref=docker.io/${{ vars.DOCKERHUB_USERNAME }}/tds-admin-frontend:buildcache

    # 4.1) No SCP needed; we'll git-sync the repo on the droplet in the next step.

    # 5) SSH into the droplet and deploy the new images using Docker Compose.
    #    Notes:
    #    - We pass GITHUB_SHA, DOCKERHUB_USERNAME and DOCKERHUB_TOKEN to the remote shell for pulling images.
    #    - We combine the base and prod compose files so services have full definitions.
    #    - We skip the admin-frontend service because it's commented out in compose files.
    - name: Deploy to DigitalOcean Droplet
      uses: appleboy/ssh-action@v1.0.3
      env:
        DOCKERHUB_USERNAME: ${{ vars.DOCKERHUB_USERNAME }}
        DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        DEPLOY_BRANCH: ${{ github.ref_name }}
      with:
        host: ${{ vars.DROPLET_HOST }}
        username: ${{ secrets.DROPLET_USERNAME }}
        key: ${{ secrets.DROPLET_SSH_KEY }}
        envs: GITHUB_SHA,DOCKERHUB_USERNAME,DOCKERHUB_TOKEN,DEPLOY_BRANCH
        script: |
          echo '#!/bin/bash' > /tmp/deploy.sh
          echo 'set -euo pipefail' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'echo "=== SHELL DEBUG INFO ==="' >> /tmp/deploy.sh
          echo 'echo "Current shell: $0"' >> /tmp/deploy.sh
          echo 'echo "SHELL variable: $SHELL"' >> /tmp/deploy.sh
          echo 'echo "Available shells:"' >> /tmp/deploy.sh
          echo 'ls -la /bin/*sh' >> /tmp/deploy.sh
          echo 'echo "========================="' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'cd /var/www/tds-admin' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'if [ -d .git ]; then' >> /tmp/deploy.sh
          echo '  git fetch --all --prune || true' >> /tmp/deploy.sh
          echo '  echo "Deploying branch: $DEPLOY_BRANCH"' >> /tmp/deploy.sh
          echo '  git reset --hard "origin/$DEPLOY_BRANCH" || true' >> /tmp/deploy.sh
          echo 'fi' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'if docker compose version >/dev/null 2>&1; then' >> /tmp/deploy.sh
          echo '  COMPOSE="docker compose"' >> /tmp/deploy.sh
          echo 'elif command -v docker-compose >/dev/null 2>&1; then' >> /tmp/deploy.sh
          echo '  COMPOSE="docker-compose"' >> /tmp/deploy.sh
          echo 'else' >> /tmp/deploy.sh
          echo '  echo "docker compose not found. Please run setup-server-initial.sh on the droplet to install Compose."' >> /tmp/deploy.sh
          echo '  exit 1' >> /tmp/deploy.sh
          echo 'fi' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'export COMPOSE_PROFILES=production' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'PORT_FILE="/var/lib/multi-app-ports"' >> /tmp/deploy.sh
          echo 'if [ -f "$PORT_FILE" ]; then' >> /tmp/deploy.sh
          echo '  NGINX_PORT=$(grep "^tds-admin:" "$PORT_FILE" | cut -d: -f2 || echo "8080")' >> /tmp/deploy.sh
          echo '  export NGINX_PORT' >> /tmp/deploy.sh
          echo '  echo "Using assigned nginx port: $NGINX_PORT"' >> /tmp/deploy.sh
          echo 'else' >> /tmp/deploy.sh
          echo '  echo "Port file not found, using default port 8080"' >> /tmp/deploy.sh
          echo '  export NGINX_PORT=8080' >> /tmp/deploy.sh
          echo 'fi' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'export DOCKER_CONFIG=$(mktemp -d)' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'echo "$DOCKERHUB_TOKEN" | docker login docker.io -u "$DOCKERHUB_USERNAME" --password-stdin' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'printf "%s\\n" "services:" "  backend:" "    image: docker.io/${DOCKERHUB_USERNAME}/tds-admin-backend:${GITHUB_SHA}" "  frontend:" "    image: docker.io/${DOCKERHUB_USERNAME}/tds-admin-frontend:${GITHUB_SHA}" > docker-compose.deploy.yml' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'COMPOSE_FILES="-f docker-compose.yml -f docker-compose.production.yml -f docker-compose.deploy.yml"' >> /tmp/deploy.sh
          echo 'echo "Starting services with compose files: $COMPOSE_FILES"' >> /tmp/deploy.sh
          echo 'echo "Using profiles: $COMPOSE_PROFILES"' >> /tmp/deploy.sh
          echo '$COMPOSE $COMPOSE_FILES up -d --pull always --no-build' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'echo "Services after startup:"' >> /tmp/deploy.sh
          echo '$COMPOSE $COMPOSE_FILES ps' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'echo "Backend health status:"' >> /tmp/deploy.sh
          echo '$COMPOSE $COMPOSE_FILES ps backend || true' >> /tmp/deploy.sh
          echo 'echo "Frontend health status:"' >> /tmp/deploy.sh
          echo '$COMPOSE $COMPOSE_FILES ps frontend || true' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'if ! $COMPOSE $COMPOSE_FILES ps | grep -q "nginx.*Up"; then' >> /tmp/deploy.sh
          echo '  echo "Nginx not running, trying to start it explicitly..."' >> /tmp/deploy.sh
          echo '  $COMPOSE $COMPOSE_FILES up -d nginx || true' >> /tmp/deploy.sh
          echo 'fi' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo '$COMPOSE $COMPOSE_FILES exec -T nginx nginx -s reload || true' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'docker image prune -f || true' >> /tmp/deploy.sh
          echo 'docker logout docker.io || true' >> /tmp/deploy.sh
          echo 'rm -rf "$DOCKER_CONFIG" || true' >> /tmp/deploy.sh
          echo '' >> /tmp/deploy.sh
          echo 'echo "Deployment completed successfully!"' >> /tmp/deploy.sh
          chmod +x /tmp/deploy.sh
          /bin/bash /tmp/deploy.sh
          rm -f /tmp/deploy.sh

    # 6) External health check. Our API is proxied under /api via nginx, so we check /api/health.
    - name: Health Check
      run: |
        sleep 30
        curl -f https://${{ vars.DOMAIN }}/api/v1/health || exit 1
